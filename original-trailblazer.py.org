#+TITLE: trailblazer : a tool for narrative programming

* module trailblazer

** imports

#+name: @imports
#+begin_src python

  import cStringIO
  import logging
  import os
  import sys
  import unittest
  import xml.sax

  from handy import xmlEncode
  from narrative import testcase
  from pygments import highlight
  from pygments.formatters import HtmlFormatter
  from pygments.lexers import JavascriptLexer
  from pygments.lexers import get_lexer_for_filename

#+end_src

** TODO usage

# clarify this: it's (the file generated by org-mode here)

- import as a python module
- run as a command line tool:
    - trailblazer.py filename
    - trailblazer.py --test

happy trails.

** outline

#+begin_src python :tangle "../.gen/Trailblazer.py" :padline yes :noweb tangle
  """
  trailblazer: a tool for narrative programming
  (c) copyright 2005, 2012 sabren enterprises inc. all rights reserved.
  """

  <<@imports>>

  <<@consts>>

  <<@classes>>
  <<@routines>>

  <<@tests>>

  def main(file):
      <<@main>>

  # run the tests
  if __name__=="__main__":
      arg = sys.argv.pop()
      if arg == "--test":
          unittest.main()
      else:
          main(arg)


#+end_src


* interface

** @clasess

*** TODO merge Trail/Solution
**** Solution

#+name: @classes
#+begin_src python

  class Solution(object):
      """
      This is the 'Trail' object.
      """
      splitter = "."  # for paths

      # magic methods
      <<Solution.__init__>>
      <<Solution.__iter__>>
      <<Solution.__getitem__>>
      <<Solution.__str__>>

      # public interface
      <<Solution.append>>
      <<Solution.blaze>>
      <<Solution.addChild>>
      <<Solution.clear>>
      <<Solution.extend>>
      <<Solution.getBlazes>>
      <<Solution.hide>>
      <<Solution.hideAll>>
      <<Solution.placeHolder>>
      <<Solution.show>>
      <<Solution.snapShot>>
      <<Solution.visibleParts>>

#+end_src

**** Trail

#+name: @classes
#+begin_src python

  class Trail(object):
      <<Trail.__init__>>
      <<Trail.__str__>>

  <<@patches/Trail>>

#+end_src

*** TODO merge Trailblazer/BlazeHound
**** BlazeHound

#+name: @classes
#+begin_src python

  class BlazeHound(xml.sax.ContentHandler):
      <<BlazeHound.__init__>>

      # sax protocol
      <<BlazeHound.characters>>
      <<BlazeHound.ignorableWhitespace>>
      <<BlazeHound.skippedEntity>>
      <<BlazeHound.startElement>>
      <<BlazeHound.endElement>>

      # specific tags
      <<BlazeHound.end_special>>
      <<BlazeHound/normal-tags>>
      <<BlazeHound/blaze-tag>>
      <<BlazeHound/extend-tag>>
      <<Blazehound/replace-tag>>
      <<BlazeHound.parse>>
      <<BlazeHound.parseString>>

#+end_src

**** Traiblazer

#+name: @classes
#+begin_src python
  class TrailBlazer(dict):
      <<@Trailblazer>>
#+end_src

*** TODO Lesson is really an OutputBuffer or something

#+name: @classes
#+begin_src python

  class Lesson(object):
      """
      A virtual output file for holding the contents of a lesson.
      """
      <<Lesson.__init__>>
      <<Lesson.showText>>
      <<Lesson.write>>

#+end_src

** @routines

#+name: @routines
#+begin_src python

  <<parseBlaze>>
  <<loadTBFile>>
  <<wipeout>>
  <<listHiddenBlazes>>

#+end_src


* implementation

** the trailblazer experiment

Narrative programming is like literate programming with version control and refactoring built in. That is, instead of simply presenting the finished parts of the program, we present instructions for building the finished program, starting from scratch.

Trailblazer is a narrative programming tool, and it is itself written in a narrative style. Unit tests and code are woven through this document. The document that you are reading at this very moment is the actual source code for trailblazer. It is meant to be read from beginning to end, like an essay.

Some of the code in this implementation is rather kludgy simply because of the bootstrapping problem: I am attempting to use a narrative programming style without actually having a narrative
programming tool. Instead I am leaning heavily on python's dynamic programming features, rearranging classes and methods at runtime.

Future narrative programs, written with the help of this very tool,
will be much cleaner. :)

Let's begin.

** Trails

*** trails

A trail is just a thread of text or code chunks woven through our narrative.

A simple trail has two parts: a head and a tail, which can be null. For example:

#+name: @tests
#+begin_src python

  @testcase
  def test_trail_simple(self):
      s = Trail("hello")
      self.assertEquals("hello", str(s))

  @testcase
  def test_trail_complete(self):
      s = Trail("hello", "(world)")
      self.assertEquals("hello(world)", str(s))

#+end_src

That test will fail because we don't have trails yet. So:

*** creating trails

#+name: Trail.__init__
#+begin_src python

  def __init__(self, head, tail=""):
      self.head = head
      self.tail = tail

#+end_src

#+name: Trail.__str__
#+begin_src python

  def __str__(self):
      # stringify everything so we can use any type:
      return str(self.head) + str(self.tail)

#+end_src

*** extending trails

One thing you can do with trails is extend them. You extend trails with other trails:

#+name: @tests
#+begin_src python

  @testcase
  def test_trail_extension(self):
      s = Trail("HEAD[","]TAIL")
      s.extend(Trail("head:","tail"))
      self.assertEquals("HEAD[head:tail]TAIL", str(s))

#+end_src


This test fails because we haven't implemented Trail.extend.

At this point, we have a bootstrap problem because we actually need the feature we're implementing. Do you see it? We've already defined the Trail class. Now we want to add a method. Now, it would be pretty easy for me, as I write this, to just jump back a few lines in my text editor and add the method to the Trail class. That's how programming normally works.

But the point of the narrative approach is to explain how the code works in little chunks. If I were sitting with you at a computer and trying to demonstrate this idea, I'd introduce a problem in the form of a test case, explain why it fails, and then present the solution by going back and editing the code.

So there's our conflict: I want to edit the class, which would normally lead me to scroll up there in my editor and change it directly, but that would break the narrative flow.

Thankfully python lets us add a method to a class after the fact.  All we have to do is define a freestanding function and glue it onto the class:

#+name: @patches/Trail
#+begin_src python

  def _Trail_extend(self, other):
      self.head=Trail(self.head, other)

  Trail.extend = _Trail_extend

#+end_src


Well, that was easy enough. If python lets us do that, why bother with trailblazer at all? Simply because we often want to do the same thing for things besides python. For example, we might want to include changes to the documentation in our narrative, or we might need to use
code from other languages - even multiple other languages. Trailblazer solves the generic problem.

Anyway, with that simple change, the tests now pass. Now that we can represent a Trail, how should we handle them?

*

** TrailBlazing

To blaze a trail is to mark it so that others can follow. Before a trail is blazed, it's no different than the surrounding landscape. The trailblazer's job, therefore, is to scout ahead and find a good path from the beginning to the end, and mark that path so that others can follow.

At times, we might seem to be making progress, only to find that our way is blocked, and that we need to backtrack and try a different approach. Slowly, we extend the trail until we reach the goal.

When we program, we start with a problem and search for a solution. If we don't leave a trail for others to follow, we may very well find a solution, but we may have a hard time telling someone else where it is. Too often, documentation (if it exists) simply describes what the solution looks like, but never tells anyone how to get there.

Right now, we're blazing a trail for future programmers, but our tools are still crude. Consider:

We were able to go back and extend the Trail class because python lets us refer to both classes and functions by name.  It's easy to add methods to classes, but what if we wanted to add another statement to a method?

For example, say we wanted to add a plot twist to a story written in python...

*** the story example

#+name: @rhetorical
#+begin_src python

  def StoryExample():
      once_upon_a_time()
      the_end()

#+end_src

... we'd have to rewrite the whole thing:

#+name: @rhetorical
#+begin_src python

  def StoryExample():
      once_upon_a_time()
      something_happened()
      the_end()

#+end_src

There's no way to tell python to just stick something in the middle like that. In python, classes, methods, and functions are first class citizens but individual statements are not.

Actually, we could use the =compiler= module to get at the individual statements, but of course that would only let us deal with python source code, and even then it would be a lot of work.

Because they are generic, Trails handle this case easily. By treating the code as a Trail, we can create an arbitrary extension point:

#+name: @tests
#+begin_src python

  @testcase
  def test_story_trail(self):
      <<basic-story-test>>

#+end_src

#+name: basic-story-test
#+begin_src python

  story=Trail(
      # head:
      ("def story():\n"
       "    once_upon_a_time()\n"),

      # == extension point ==

      # tail:
      ("    the_end()\n"))

  # now add the line:
  story.extend("    something_happened()\n")
  self.assertEquals(("def story():\n"
                     "    once_upon_a_time()\n"
                     "    something_happened()\n"
                     "    the_end()\n"),
                    str(story))

#+end_src

Easy!

*** more story tests

But wait a second. Suppose we want to add a foreword to our story, or a postscript. Since there's only one extension point, we're out of luck. If we call =story.extend= again, it'll just keep adding stuff before =the_end()=:

#+name: @tests
#+begin_src python

  @testcase
  def more_to_the_story(self):
      <<basic-story-test>>
      story.extend("    another_exciting_plot_twist()\n")
      story.extend("    and_so_on()\n")
      self.assertEquals(("def story():\n"
                         "    once_upon_a_time()\n"
                         "    something_happened()\n"
                         "    another_exciting_plot_twist()\n"
                         "    and_so_on()\n"
                         "    the_end()\n"),
                        str(story))

#+end_src


Obviously, we're not going to get very far with only one extension point. No problem: if we give the trails names as we add them, we can extend the system however we like:

#+begin_src python

  @testcase
  def solfege_example(self):
      # http://en.wikipedia.org/wiki/Solfege

      # the major scale (white keys):
      scale = Trail("[","]")
      do = Trail("C:") ; scale.extend(do)
      re = Trail("D:") ; scale.extend(re)
      mi = Trail("E:") ; scale.extend(mi)
      fa = Trail("F:") ; scale.extend(fa)
      so = Trail("G:") ; scale.extend(so)
      la = Trail("A:") ; scale.extend(la)
      ti = Trail("B:") ; scale.extend(ti)
      scale.extend("C")
      self.assertEquals("[C:D:E:F:G:A:B:C]", str(scale))

      # the chromatic scale (adds the black keys)
      di = Trail("C#:") ; do.extend(di)
      ri = Trail("Eb:") ; re.extend(ri)
      fi = Trail("F#:") ; fa.extend(fi)
      si = Trail("Ab:") ; so.extend(si)
      li = Trail("Bb:") ; la.extend(li)
      self.assertEquals("[C:C#:D:Eb:E:F:F#:G:Ab:A:Bb:B:C]", str(scale))

#+end_src

This test runs fine, so, in theory, we already have the power we're looking for.  However it would be cumbersome to write each narrative as a python script. Ideally, we'd write the narrative in some author-friendly markup language, and decorate the trails with blazes (markers) as we go along.

*** Solfege test

Here's how TrailBlazer ought to work:

#+name: @tests
#+begin_src python

  def make_solfege_scale():
      scale = TrailBlazer(Trail("[","]"))
      scale["do"] = Trail("c:")
      scale["re"] = Trail("d:")
      scale["mi"] = Trail("e:")
      scale["fa"] = Trail("f:")
      scale["so"] = Trail("g:")
      scale["la"] = Trail("a:")
      scale["ti"] = Trail("b:")
      scale["DO"] = Trail("C")
      return scale

  @testcase
  def solfege_trail_test(self):
      self.assertEquals("[c:d:e:f:g:a:b:C]", str(make_solfege_scale()))

#+end_src

It's easy enough to pass the test:

** The Trailblazer class

#+name: @Trailblazer
#+begin_src python

      def __init__(self, trail):
          self.trail = trail

      def __str__(self):
          return str(self.trail)

      def __setitem__(self, key, value):
          seg = TrailBlazer(value)
          self.trail.extend(seg)
          dict.__setitem__(self, key, seg)

#+end_src

However, there is a problem at this point:

#+name: @tests
#+begin_src python

  bug = TrailBlazer(Trail("{","}"))
  bug["foo"]=Trail("abc.")
  bug["foo"]=Trail("123.")
  bug["foo"]=Trail("xyz")
  assert str(bug["foo"]) == "xyz"

  # unfortunately:
  assert str(bug) == "{abc.123.xyz}"

#+end_src

The code lets us reassign the marker to a new trail, but the old trail sticks around. In reality, the same thing happens with python: the old method sticks around until it gets garbage collected.

In our case, it's not enough to simply remove the old version, because the order in which trails are defined could be important, either for technical or narrative reasons (eg, if we were generating reference docs inline)

*** replacetest

What we really want is to replace the trail if it already exists:

#+name: @tests
#+begin_src python

  @testcase
  def test_replace(self):
      scale = make_solfege_scale()

      # original version:
      self.assertEquals("[c:d:e:f:g:a:b:C]", str(scale))

      # change the trails:
      for note in scale:
          scale[note] = Trail(note, " ")

      self.assertEquals("[do re mi fa so la ti DO ]", str(scale))

      # remove the final space:
      scale["DO"] = Trail("DO")
      self.assertEquals("[do re mi fa so la ti DO]", str(scale))

#+end_src


Now, we want to keep the original behavior if we're blazing a trail for the first time. We can preserve that behavior by renaming the old =TrailBlazer.__setitem__= to =.blaze=...

#+begin_src python

  TrailBlazer.blaze = TrailBlazer.__setitem__

#+end_src


... and replacing =__setitem__= with something like this:

#+begin_src python

  def _TrailBlazer___setitem__(self, key, value):
      if key in self:
          self.replace(key, value)
      else:
          self.blaze(key, value)

  def _TrailBlazer_replace(self, key, value):
      self[key].trail = value

  TrailBlazer.__setitem__ = _TrailBlazer___setitem__
  TrailBlazer.replace = _TrailBlazer_replace

#+end_src


We can extend any sub trail by using the qualified name. We might also want to extend the master trail:

** extend test
#+name: @tests
#+begin_src python

  class TrailBlazerExtendTest(unittest.TestCase):
      def test(self):
          trail = TrailBlazer(Trail("[",";"))
          trail.extend("]")
          self.assertEquals(str(trail), "[];")

  def _TrailBlazer_extend(self, content):
      self.trail.extend(content)

  TrailBlazer.extend = _TrailBlazer_extend

#+end_src

** TODO implement deletion. meanwhile: trail.replace("deleted", Trail(""))

** BlazeHoundTest

At this point, we have everything we need to build our trails as we go along. But if you really think about it, you'll realize we need two trails: one for people to follow and one for our compiler to follow.

The people trail takes the form of plain old words in our markup language. The narrative /is/ the people trail.

We also need a trail so that the computer can follow along and read our instructions and build the final program. So far python's doing that job, but we've had to do a lot of tedious work at runtime to make it happen. Now that we have TrailBlazer, we can implement a something to sniff out trails that we've defined in an external file, and lead the compiler along after us. Let's call it a =BlazeHound=.

How a BlazeHound works kind of depends on the markup language we're using. From the outside, all we want is to is to load a file. How we parse that file kind of depends on what sort of markup language we choose. We're going to implement a simple XML BlazeHound.

Let's start with a simple test:

#+name: @tests
#+begin_src python

  def normalizeWhiteSpace(s):
      return " ".join(str(s).split())

  @testcase
  def test_blazehound(self):
      hound = BlazeHound()
      hound.parseString(
          '<xml>[<trail:blaze name="abc">xyz</trail:blaze>]</xml>')
      self.assertEquals("[xyz]", normalizeWhiteSpace(hound.trail))
      self.assertEquals("xyz", normalizeWhiteSpace(hound.trail["abc"]))

#+end_src

This is a simple test, but it actually takes quite a bit of work:

** BlazeHound implementation

#+name: @classes
#+begin_src python

  class BlazeHound(xml.sax.ContentHandler):
      <<BlazeHound.__init__>>
      <<BlazeHound.startElement>>
      <<BlazeHound.endElement>>
      <<BlazeHound.parseString>>
      <<BlazeHound.characters>>

#+end_src

#+name: BlazeHound.__init__
#+begin_src python

    def __init__(self):
      self.stack = []
      self.this  = Trail("")
      self.trail = TrailBlazer(self.this)

#+end_src

#+name: BlazeHound.startElement
#+begin_src python

  def startElement(self, name, attrs):
      # this isn't the right way to do namespaces, but
      # since we're just bootstrapping here, we'll let
      # it slide:
      if name=="trail:blaze":
          self.stack.append(self.this)
          self.this = new = Trail("")
          self.trail[attrs["name"]]=new

#+end_src

#+name: BlazeHound.endElement
#+begin_src python

  def endElement(self, name):
      if name=="trail:blaze":
          self.this = self.stack.pop()

#+end_src

#+name: BlazeHound.parseString
#+begin_src python

  def parseString(self, s):
      xml.sax.parseString(s, self)

#+end_src

#+name: BlazeHound.characters
#+begin_src python

  def characters(self, content):
      self.this.extend(content)

#+end_src

** BlazeHound full test

#+name: @tests
#+begin_src python

  @testcase
  def test_blazehound_full(self):
      xml =\
          '''
          <xml>
            <trail:blaze name="story">
            Once upon a time.
            <trail:split/>
            The end.
            </trail:blaze>
            <trail:extend trail="story">
            Something happened.
            </trail:extend>
          </xml>
          '''
      hound = BlazeHound()
      hound.parseString(xml)
      self.assertEquals(
          "Once upon a time. Something happened. The end.",
          normalizeWhiteSpace(hound.trail))

#+end_src

** solution class
*** Solution.__init__
#+name: Solution.__init__
#+begin_src python

  def __init__(self):
      self.parts = []
      self.visible = True
      self.blazes = {}

#+end_src

*** Solution.__iter__
#+name: Solution.__iter__
#+begin_src python

  def __iter__(self):
      for item in self.parts:
          if isinstance(item, Solution):
              for child in item:
                  yield child
          else:
              yield item

#+end_src
*** Solution.____getitem__
#+name: Solution.__getitem__
#+begin_src python

  def __getitem__(self, trail):
      split = trail.split(self.splitter, 1)
      head, tail = split[0], split[1:]
      assert len(tail) in [0,1] # because of 1 in trail.split()
      if tail:
          return self.getBlazes()[head][tail[0]]
      else:
          return self.getBlazes()[head]

#+end_src
*** Solution.__str__
#+name: Solution.__init__
#+begin_src python

  def __str__(self):
      return "".join(self)

#+end_src
*** Solution.append
#+name: Solution.append
#+begin_src python

  def append(self, x):
      self.parts.append(x)

#+end_src

*** Solution.blaze
#+name: Solution.blaze
#+begin_src python

  def blaze(self, name):
      return self.addChild(name, self.placeHolder())

#+end_src

*** Solution.addChild
#+name: Solution.addChild
#+begin_src python

  def addChild(self, name, child):
      self.getBlazes()[name] = child
      self.append(child)
      return child

#+end_src

*** Solution.clear
#+name: Solution.clear
#+begin_src python

  def clear(self, trail=None):
      if trail:
          self[trail].clear()
      else:
          self.parts = []
          self.blazes = {}

#+end_src

*** Solution.extend
#+name: Solution.extend
#+begin_src python

  def extend(self, other):
      self.parts.extend(other.parts)
      for k, v in other.getBlazes().items():
          self.getBlazes()[k] = v

#+end_src

*** Solution.getBlazes
#+name: Solution.getBlazes
#+begin_src python

  def getBlazes(self):
      return self.blazes

#+end_src

*** Solution.hide
#+name: Solution.hide
#+begin_src python

  def hide(self):
      self.visible = False

#+end_src

*** Solution.hideAll
#+name: Solution.hideAll
#+begin_src python

  def hideAll(self):
      self.hide()
      for kid in self.blazes.values():
          kid.hideAll()

#+end_src

*** Solution.placeHolder
#+name: Solution.placeHolder
#+begin_src python

  def placeHolder(self):
      return Solution()

#+end_src

*** Solution.show
#+name: Solution.show
#+begin_src python

  def show(self):
      self.visible = True

#+end_src

*** Solution.snapShot
#+name: Solution.snapShot
#+begin_src python

  def snapShot(self):
      if self.visible:
          return "".join(list(self.visibleParts()))
      else:
          return ""

#+end_src

*** Solution.visibleParts
#+name: Solution.visibleParts
#+begin_src python

  def visibleParts(self):
      for item in self.parts:
          if isinstance(item, Solution):
              yield item.snapShot()
          else:
              yield item

#+end_src

** TEST Solutions are like string buffers.

The solution compiler should be easy: just "for x in solution" or list(solution)

#+name: @tests
#+begin_src python

  @testcase
  def testSolution(self):
      # is like a list but you can only append
      s = Solution()
      assert list(s) == []
      s.append("a")
      assert list(s) == ["a"]
      s.append("b")
      s.append("c")
      assert list(s) == ["a","b","c"]
      assert str(s) == "abc"

#+end_src

** TODO document this
- want to give big picture and fill details in later
- explain what trailblazing is
- blaze(name) maps name to a position on the list

** BlazeTest
#+name: @tests
#+begin_src python

  class BlazeTest(unittest.TestCase):

      def setUp(self):
          s = Solution()
          s.blaze("start")
          s.append("[")
          s.append("{")
          s.blaze("middle")
          s.append("}")
          s.append("]")
          s.blaze("end")
          self.solution = s

      def test(self):
          self.assertEquals("[{}]", "".join(self.solution))
#+end_src

** BlazesShouldBeSolutions
#+name: @tests
#+begin_src python

  class BlazesShouldBeSolutions(BlazeTest):
      def test(self):
          """
          blaze should return the placeholder so that
          linehound can maintain a stack as it goes along
          """
          assert isinstance(self.solution.blaze('bleh'),Solution)

#+end_src

** TODO what is all this about placeholders?
- just map the name to a placeholder
- reason for placeholder
  - could just insert to the list but then it screws up our keys
  - so: placeholder() -> Solution()
  - we don't actualy want to see those placeholders
  - plus lose ability to iterate when we went nested
  - but easy to fix: __iter__

** want to extend without screwing up the blazes

#+name: @tests
#+begin_src python

  @testcase
  def test_solution_append(self):
      self.assertEquals("[{}]", "".join(self.solution))
      self.solution["start"].append("<")
      self.solution["middle"].append("*")
      self.solution["middle"].append("-")
      self.solution["middle"].append("*")
      self.solution["end"].append(">")
      self.assertEquals("<[{*-*}]>", "".join(self.solution))

#+end_src

Now, we could just return the key from the =getBlaze()[key]= but that doesn't allow us to follow a trail. Consider:

*** AtTest

#+name: @tests
#+begin_src python

  @testcase
  def attest(self):
      words = Solution()
      alphabet = "_abcdefghijklmnopqrstuvwxyz"

      # this is a somewhat big solution space
      # 26 x 26 = 676 blazes [25 letters + _]
      for x in alphabet:
          words.blaze(x)
          for y in alphabet:
              words[x].blaze(y)

      # add some words to the tree:
      words["t.w"].append("twas")
      words["a._"].append("a")
      words["d.a"].append("dark")
      words["a.n"].append("and")
      words["s.t"].append("stormy")
      words["n.i"].append("night")

      # they should be alphabetized now:
      self.assertEquals("a and dark night stormy twas",
                        " ".join(words))

#+end_src

**** how to extend the point? - this already works
**** how to replace the point?
**** just clear and append again

*** ClearTest
#+name: @tests
#+begin_src python

  @testcase
  def test_clear(self):
      s = Solution()
      s.append("[")
      s.blaze("content")
      s["content"].append("before")
      s.append("]")

      self.assertEquals("[before]", "".join(s))
      s.clear("content")
      self.assertEquals("[]", "".join(s))
      s["content"].append("after")
      self.assertEquals("[after]", "".join(s))

#+end_src

# finally, we wan to be able to merge two solutions together
# a list uses the extend method for this,
#+name: @tests
#+begin_src python

  @testcase
  def test_extend(self):
      a = Solution()
      a.blaze("a")
      a["a"].append("a")

      b = Solution()
      b.blaze("b")
      b["b"].append("b")

      a.extend(b)
      self.assertEquals("b", str(a["b"]))

#+end_src

# but because of the nested structures and names, we need to a little
# more work:

*** hiding nodes

While working on brickslayer, I realized it might make more sense to have all the source code in the actual files, and simply mark out chunks to be included in the narrative. This is akin to an HTML page where some of the elements are hidden by default.

Besides clearing up quite a bit of headache when it comes to explaining where code should go, and making it easier to see the entire solution with all variations at once, this makes it possible to add a trail on top of an existing codebase.

#+name: @tests
#+begin_src python
@testcase
def testSnapshot(self):

    s = Solution()
    s.append("<")

    a = s.blaze("a")
    a.append("[")

    b = a.blaze("b")
    b.append("{")
    b.append("}")

    a.append("]")
    s.append(">")

    self.assertEquals("<[{}]>", "".join(s))
    self.assertEquals("<[{}]>", s.snapShot())
    s["a.b"].hide()
    self.assertEquals("<[]>", s.snapShot())
    s["a"].hide()
    self.assertEquals("<>", s.snapShot())
    s["a.b"].show()
    self.assertEquals("<>", s.snapShot())

#+end_src

** class BlazeHound compiles the code

This is BlazeHound, our XML-based solution compiler.

Use this if you want to build the entire solution up through the narrative with all the code embedded directly in the xml.

If your code is in a source file with tags embedded in the comments, you want to use LineHound.

Here's what we're shooting for: We should be able to put a bunch of ideas in the same file and have it all mixed up, and modify things as we go along so that we're able to explain things in nice little pieces... But then in the end we want the computer to be able to go back and compile all the trails into the full solution, dumping the tests to one place, the final code to another, and the docs somewhere else. So basically we want to parse an xml file and build a Solution.

#+name: @tests
#+begin_src python

  class BlazeHoundTest(unittest.TestCase):

      def test(self):
          hound = BlazeHound()
          sol = hound.parseString(
          '''\
          <xml>
            <trail:blaze trail="char">
              <trail:blaze trail="alpha">XYZ</trail:blaze>
              <trail:blaze trail="number">123</trail:blaze>
            </trail:blaze>
            <trail:extend trail="char.number">456</trail:extend>
            <trail:replace trail="char.alpha">ABC</trail:replace>
            <trail:extend trail="char.alpha">DEF</trail:extend>
          </xml>\
          ''')
          logging.debug(sol.getBlazes())
          logging.debug(list(sol))

          # so the alpha and number areas should be easy:
          self.assertEquals("ABCDEF", str(sol["char.alpha"]))
          self.assertEquals("123456", str(sol["char.number"]))

          # and if we clear out the whitespace:
          self.assertEquals("ABCDEF123456",
                            "".join(str(sol["char"]).split()))

#+end_src

So the idea is pretty straightforward. We're just going to parse the XML file and add all the chunks to a Solution. So in terms of our technology, we want to create a Saxophone with some TagHandlers that build a Solution object from the xml tags.

Since state machines are kind of tricky, we can use the logging module to help us see what's happening.

To see the log output, just uncomment this next line:


#+begin_src python

# logging.root.setLevel(logging.DEBUG)

#+end_src

So... Our XML format has three tags. We're going to skirt around the whole issue of xml namespaces here, because by default, xml.sax just ignores the colon and returns the whole qualified name as a string. This means "trail:"
isn't a real xml namespace. That should probably be fixed later.

*** TODO clean up namespace handling

#+name: @consts
#+begin_src python

TAG_BLAZE = "trail:blaze"
TAG_EXTEND = "trail:extend"
TAG_REPLACE = "trail:replace"

#+end_src

*** <
The basic TagHandler class almost does what we want, but not quite. Why? Because it's appending to a list as we go along, but what we really want to do is append to a Solution.

Ah, but which Solution? if all we had were blaze tags, then we could just make up a new Solution at the start of each tag and build up the tree using anonymous instances.

But: since we want to be able to modify the tree as we go (using the replace and extend tags) then we need to be able to walk the tree at any time. which means we need to keep a reference to the root Solution in a variable somewhere.

It also means that we can't have an anonymous Solution for each tag, which would have been easier. We need to add each child Solution to its parent immediately when we start the trail:blaze tag.

Also, if we want nested blaze tags, then we need the concept of a "current" solution as well as the "root" solution. so we need exactly one root Solution, plus a stack, containing one Solution per trail tag. (We use a stack because the tags can be nested). Finally, we need to keep track of which one is the current solution.

So:

#+name: BlazeHound.__init__
#+begin_src python

  def __init__(self, root=None):
      xml.sax.ContentHandler.__init__(self)
      self.root = root or Solution()     # root Solution
      self.stack = []            # child Solutions
      self.current = self.root   # current Solution

#+end_src

** blazehound sax events

Now, the way sax works, there are certain methods that get called as you parse from the top of the xml file to the bottom, one for each xml concept that you encounter.

*** passthrough items

So character data, whitespace, and xml entities are pretty easy. We just pass the data directly to the current Solution:

#+name: BlazeHound.characters
#+begin_src python

  def characters(self, content):
      self.current.append(content)

#+end_src

#+name: BlazeHound.ignorableWhitespace
#+begin_src python

  def ignorableWhitespace(self, whitespace):
      self.current.append(whitespace)

#+end_src

#+name: BlazeHound.skippedEntity
#+begin_src python

  def skippedEntity(self, name):
      # handle entities like &amp;
      self.current.append("&%s;" % name)

#+end_src

*** tags

Most of the tags should also just pass through unchanged to the Solution, but we need to set up some special handlers for the three tags that we defined earlier.

So, we'll just hard code some dispatch logic for these, and fill them in later:

#+name: BlazeHound.startElement
#+begin_src python

  def startElement(self, name, attrs):
      method = {
          TAG_BLAZE   : self.tag_blaze,
          TAG_EXTEND  : self.tag_extend,
          TAG_REPLACE : self.tag_replace,
      }.get(name)
      if method:
          method(attrs)
      else:
          self.tag_normal(name, attrs)

#+end_src

All these special tag handlers are going to push the current solution onto the stack, and then pick a new solution to be the current one.

After we close a special tag, we just go back to working with the previous Solution. All three special end tags will do the same thing, so we can just take care of all of them at once:

#+name: BlazeHound.endElement
#+begin_src python

  def endElement(self, name):
      method = {
          TAG_BLAZE   : self.end_special,
          TAG_REPLACE : self.end_special,
          TAG_EXTEND  : self.end_special,
      }.get(name)
      if method:
          method()
      else:
          self.end_normal(name)

#+end_src

*** BlazeHound.end_special
#+name: BlazeHound.end_special
#+begin_src python

  def end_special(self):
      self.current = self.stack.pop()

#+end_src


*** normal tags
Normal tags just pass through directly. We won't always get the exact same start tags since the attributes are turned into python dicts, which are unordered. Similarly, <empty/> tags will be turned into <empty></empty> tag pairs, but it doesn't matter: the xml is equivalent.

#+name: BlazeHound/normal-tag
#+begin_src python

  def tag_normal(self, name, attrs):
      self.current.append("<%s" % name)
      for k,v in attrs.items():
          self.current.append(' %s="%s"' % (k, v))
      self.current.append(">")

  def end_normal(self, name):
      self.current.append("</%s>" % name)

#+end_src

Now we can consider the special tags individually.

The blaze tag starts a new Solution, so we need to push the current solution onto the stack and create a new one:

*** <blaze>
#+name: BlazeHound/blaze-tag
#+begin_src python

  def tag_blaze(self, attrs):
      trail = attrs["trail"]
      # create the new child solution:
      self.current.blaze(trail)
      # push this one onto the stack
      self.stack.append(self.current)
      # and replace it with the new child
      self.current = self.current[trail]

#+end_src


*** <extend>

The extend tag jumps back to an existing solution:

#+name: BlazeHound/extend-tag
#+begin_src python

  def tag_extend(self, attrs):
      trail = attrs["trail"]
      # push this one onto the stack
      self.stack.append(self.current)
      # and replace it with the trail
      # by following the dots from the root:
      self.current = self.root[trail]

#+end_src

*** <replace>

The replace tag does the exact same thing, but it clears the previous solution first.


#+name: Blazehound/replace-tag
#+begin_src python

  def tag_replace(self, attrs):
      self.root[attrs["trail"]].clear()
      self.tag_extend(attrs)

#+end_src

And... That's really all we need.

*** convenience methods
Here are two convenience methods though:

**** parse
#+name: BlazeHound.parse
#+begin_src python

  def parse(self, filename_or_stream):
      xml.sax.parse(filename_or_stream, self)
      return self.root

#+end_src

**** parseString
#+name: BlazeHound.parseString
#+begin_src python

  def parseString(self, string):
      xml.sax.parseString(string, self)
      return self.root

#+end_src

** plain text helpers

#+name: parseBlaze
#+begin_src python

  def parseBlaze(line, prefix):
      return line[line.find(prefix)+len(prefix):].strip()

#+end_src

#+name: loadTBFile
#+begin_src python

  def loadTBFile(fileName, blaze="@:"):

      openTag = blaze
      closeTag = blaze+"/"

      top = currentSolution = Solution()
      top.fileName = fileName


      currentName = ""
      stack = []

      for lineNumber, line in enumerate(open(fileName)):

          # check for / first because the match is more specific
          if line.count(closeTag):
              name = parseBlaze(line, closeTag)
              assert name == currentName, (
                     "mismatched end tag (%s vs %s) on line %s of %s"
                     % (name, currentName, lineNumber+1, top.fileName))

              currentName, currentSolution = stack.pop()

          elif line.count(openTag):
              stack.append((currentName, currentSolution))
              currentName = parseBlaze(line, openTag)
              currentSolution = currentSolution.blaze(currentName)


          else:
              currentSolution.append(line)

      assert stack == [], "expected close tag for %s" % currentName

      return top

#+end_src


* main

** Tinderblaze - read a trailblazer narrative data from a tinderbox outline

Tinderbox files (*.tbx) are xml, but since they seem to have one tag per line, I didn't bother with an xml parser.

#+name: @routines
#+begin_src python

  def wipeout(dir):
      os.system("rm -rf %s" % dir)
      os.mkdir(dir)

  def htmlDecode(s):
      return s.replace("&apos;","'").replace("&quot;",'"').replace("&lt;","<").replace("&gt;",">")

#+end_src

** Lesson implementation

#+name: Lesson.__init__
#+begin_src python

  def __init__(self, snapName, title):
      self.title = title
      self.content = cStringIO.StringIO()
      self.summary = ''
      self.snapName = snapName

#+end_src

#+name: Lesson.showText
#+begin_src python

  def showText(self, depth, text):
      if depth == 1:
          self.summary = htmlDecode(text)
          return ''
      else:
          return '<div class="detail">%s</div>' % htmlDecode(text)

#+end_src

#+name: Lesson.write
#+begin_src python

  def write(self, text):
      self.content.write(text)

#+end_src

** <<listHiddenBlazes>>

#+name: listHiddenBlazes
#+begin_src python

  def listHiddenBlazes(node, path=[]):
      if node.visible:
          for each in node.blazes:
              newpath = path + [each]
              listHiddenBlazes(node[each], newpath)
      else:
          print ".".join(path)

#+end_src

** <<tinderblaze main code>>

#+name: @main
#+begin_src python

  if sys.platform == "win32":
      ROOT = "p:/"
  else:
      ROOT = "/Users/michal/"

#+end_src

#+name: @main
#+begin_src python

  #@TODO: unhardcode input filename
  inputStream = (open(sys.argv[1]) if len(sys.argv) > 1
                 else open(ROOT + 'keep/brickslayer.tbx'))

#+end_src

#+name: @main
#+begin_src python

  HTMLformat = HtmlFormatter(cssclass="source")
  # print HTMLformat.get_style_defs() # dump css rules

  trail = Solution()

#+end_src


#+name: @main
#+begin_src python

  mainDir = ROOT + "sites/javascriptgamer.com/brickslayer"
  codeDir = mainDir + "/code"

  # careful! the snapdir gets wiped out!
  snapDir = mainDir + "/snap"
  wipeout(snapDir)

  # same with the traildir
  trailDir = mainDir + "/trail"
  wipeout(trailDir)

  os.chdir(codeDir)

  textMode = False
  textBuff = [] # cstringio?

#+end_src

#+name: @main
#+begin_src python

  prompt = '<span class="gp">&gt;&gt;&gt; </span>'

#+end_src

#+name: @main
#+begin_src python

  trash = Lesson('trash','trash')
  lessons = []
  contents = []
  out = trash
  static = {} # static files
  lastSnap = None
  prev, next = {}, {}
  title = None
  trigger = {} # depth trigger

#+end_src

** main parser / line matcher / state machine

#+name: @main
#+begin_src python

  depth = 0
  for line in inputStream:

      # text nodes
      if textMode:
          if line.count("</text>"):
              <<end:text>>
          else:
              <<add:text>>
      elif line.startswith("<text >"):
          <<tag:text>>

      # handle nesting
      elif line.startswith("<item"):
          <<tag:item>>
      elif line.startswith("</item"):
          <<end:item>>

      # deal with headline(name) for each note
      elif line.startswith('<attribute name="Name"'):
          name = line.split(">")[1].split("<")[0]
          # if special headline
          <<@headlines>>
          else:
              print >> out, "<h%s>%s</h%s>" % (depth, name, depth)

#+end_src

*** text

#+name: end:text
#+begin_src python

  textMode = False
  textBuff.append(line[:line.find("</text>")])
  print >> out, out.showText(depth, "".join(textBuff))

#+end_src

#+name: add:text
#+begin_src python

  textBuff.append(line)

#+end_src

#+name: tag:text
#+begin_src python

  if line.count("</text>"):
      print >> out, out.showText(depth, line[7:line.find("</text>")])
  else:
      textBuff = [line[7:]]
      textMode = True

#+end_src

*** items

#+name: tag:item
#+begin_src python

  depth += 1

#+end_src

**** TODO what are these trigger things?
#+name: end:item
#+begin_src python

  depth -= 1
  if trigger.get(depth):
      trigger[depth]()
      trigger[depth] = None

#+end_src

*** headlines
**** use "#" prefix for comments
#+name: @headlines
#+begin_src python

  if name.startswith("#"):
      out = trash

#+end_src

**** TODO  ";" prefix is for paragrphs without headlines

how is this separate from just plain text?

#+name: @headlines
#+begin_src python

  elif name.startswith(";"):
      # this is so we can add paragraphs without headlines
      print >> out, "<p>%s</p>" % name[2:]

#+end_src

**** "@TODO" items
#+name: @headlines
#+begin_src python

  elif name.upper().startswith("@TODO"):
      print >> out, '<h1 style="background:#FF0;color:black;font-size:12pt">%s</h1>' % name

#+end_src

**** TODO whas is "%" is for?
#+name: @headlines
#+begin_src python

  # new lesson marker
  elif name.startswith('% '):
      oldTitle = title
      snapName, title = [s.strip() for s in name.split("%") if s]
      out = Lesson(snapName, title)
      if lastSnap:
          prev[snapName] = (lastSnap, oldTitle)
          next[lastSnap] = (snapName, title)
      else:
          prev[snapName] = None # handle first one
      next[snapName] = None # handle last one
      lastSnap = snapName
      lessons.append(out)
      depth = 1

#+end_src

**** "<" is for javascript
#+name: @headlines
#+begin_src python

  elif name.startswith("&gt; "):
      html = highlight(htmlDecode(name[5:]), JavascriptLexer(), HTMLformat)
      cutPoint = html.find("<span")
      print >> out, html[:cutPoint] + prompt + html[cutPoint:]

#+end_src

**** "firebug" just changes the output format
#+name: @headlines
#+begin_src python

  elif name.lower().startswith("firebug"):
      print >> out, '<div class="firebug">'
      print >> out, "<h%s>%s</h%s>" % (depth, name, depth)
      trigger[depth-1] = lambda : out.write('</div>')

#+end_src

*** blazes headlines with @ sigils
**** blaze sigils
#+name: @main
#+begin_src python

  loadBlaze = "@="
  showBlaze = "@+"
  hideBlaze = "@-"
  snapBlaze = "@!"

#+end_src

**** loadBlaze
#+name: @headlines
#+begin_src python

  # blazes
  elif name.startswith(loadBlaze):
      root, filename = name[2:].strip().split(" ",1)
      # handle tb files
      if os.path.exists(filename + ".tb"):
          tree = trail.addChild(root, loadTBFile(filename+'.tb'))
          tree.outFile = filename
          tree.hideAll()
      # handle static files
      elif os.path.exists(filename):
          static[filename] = open(filename).read()
      else:
          raise Exception("not found: %s" % filename)

#+end_src

**** showBlaze
#+name: @headlines
#+begin_src python

  elif name.startswith(showBlaze):
      path = parseBlaze(name, showBlaze)
      try:
          trail[path].show()
      except KeyError:
          raise KeyError( path)

      code = trail[path].snapShot()


      # add a fake <? php so the syntax highlight works
      snip = False
      if path.startswith("php") and not (code.startswith("<?php")):
          code = "<?php\n"+code
          snip = True


      html = highlight(code,
                       get_lexer_for_filename(trail[path.split(".")[0]].outFile),
                       HTMLformat)

      # remove the fake <? php
      if snip:
          match = '<span class="cp">&lt;?php</span>'
          point = html.find(match)
          html = html[:point] + html[point+len(match):]
      print >> out, html

#+end_src

**** hideBlaze
#+name: @headlines
#+begin_src python

  elif name.startswith(hideBlaze):
      path = parseBlaze(name, hideBlaze)
      print >> out, '<pre class="hide">%s</pre>' % xmlEncode(trail[path].snapShot())
      trail[path].hide()

#+end_src
**** TODO what's snapBlaze ?
#+name: @headlines
#+begin_src python

  elif name.startswith(snapBlaze):
      # make snapshots in directory snap/snapName
      snapName = parseBlaze(name, snapBlaze)
      snapPath = os.path.join(snapDir, snapName)
      os.mkdir(snapPath)
      for item in trail.blazes.values():
          if item.visible:
              fileName = item.fileName
              f = open(os.path.join(snapPath, item.outFile), "w")
              f.write(item.snapShot())
              f.close()

      for k,v in static.items():
          f = open(os.path.join(snapPath, k), 'wb')
          f.write(v)
          f.close()

      os.chdir(snapDir)
      os.system("tar -czf %s.tgz %s" % (snapName, snapName))
      os.system("mv %s.tgz %s" % (snapName, trailDir))
      os.chdir(codeDir)

      out.minigame = trail['html.console'].snapShot() + trail['html.onload'].snapShot()

#+end_src

** output for jsgamer
*** TODO move this output part to a zebra template

#+name: @main
#+begin_src python

  implan = cStringIO.StringIO()
  print >> implan, "<h2>Development Trail</h2>"

#+end_src

#+name: @main
#+begin_src python

  template = open(os.path.join(mainDir,'template.html')).read()

  for num, each in enumerate(lessons):
      trailFileName = "%02i-%s.html" % (num, each.snapName)
      trailFile = open(os.path.join(trailDir, trailFileName), 'w')

      navBar = ['<div style="background: #CCCCCC; height: 25px;">']
      if prev[each.snapName]:
          navBar.append('<span style="float:left">previous: <a href="%02i-%s.html">%s</a></span>'
                        % (num-1, prev[each.snapName][0], prev[each.snapName][1]))
      if next[each.snapName]:
          navBar.append('<span style="float:right">next: <a href="%02i-%s.html">%s</a></span>'
                        % (num+1, next[each.snapName][0], next[each.snapName][1]))

      navBar.append('<br clear="all"/></div>')

      snapName = '%02i-%s' % (num, each.snapName)
      if each.snapName == 'enhancements':
          snapName = 'final'

      print >> trailFile, template % {
          'title' : each.title,
          'htmlTitle' : 'Building Brickslayer - %s' % each.title,
          'summary' : each.summary,
          'content' : each.content.getvalue(),
          'crumbs' : '<a href="./">trail</a> &gt; step %02i' % num,
          'minigame': each.minigame,
          'snapName': snapName,
          'navBar' : ''.join(navBar),
      }

      print >> implan, "<p style='margin:0px; margin-top:5px;font-weight:bold;'>%02i." % num
      print >> implan, '<a href="%s">%s</a></p>' % (trailFileName, each.title)
      if each.summary:
          print >> implan, each.summary
      else:
          print >> implan, "<br/>"

#+end_src

*** apply the template
#+name: @main
#+begin_src python

  index = open(os.path.join(trailDir, 'index.html'), 'w')
  print >> index, template % {
      'title' : "Building Brickslayer",
      'htmlTitle' : 'Building Brickslayer',
      'summary' : "How to make a BreakOut clone in Javascript using Prototype.js",
      'content' : implan.getvalue(),
      'crumbs' : 'trail',
      # each is still the final version...
      'minigame': each.minigame,
      'snapName': 'final',
      'navBar' : '',
  }

#+end_src

*** report on the results of the generation
#+name: @main
#+begin_src python

  print "hidden nodes:"
  print "-------------"
  listHiddenBlazes(trail)

#+end_src
